
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>md_harmonize.KEGG_parser &#8212; md_harmonize 1.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for md_harmonize.KEGG_parser</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">md_harmonize.KEGG_parser</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">This module provides functions to parse KEGG data (including compound, reaction, kcf, and rclass).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">compound</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">reaction</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tools</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span> <span class="k">as</span> <span class="nn">CF</span>
<span class="kn">import</span> <span class="nn">pebble</span>


<div class="viewcode-block" id="kegg_data_parser"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.kegg_data_parser">[docs]</a><span class="k">def</span> <span class="nf">kegg_data_parser</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is to parse KEGG data (reaction, rclass, compound) file to a dictionary.</span>

<span class="sd">    eg:</span>

<span class="sd">    ENTRY       R00259                      Reaction</span>

<span class="sd">    NAME        acetyl-CoA:L-glutamate N-acetyltransferase</span>

<span class="sd">    DEFINITION  Acetyl-CoA + L-Glutamate &lt;=&gt; CoA + N-Acetyl-L-glutamate</span>

<span class="sd">    EQUATION    C00024 + C00025 &lt;=&gt; C00010 + C00624</span>

<span class="sd">    RCLASS      RC00004  C00010_C00024</span>

<span class="sd">                RC00064  C00025_C00624</span>

<span class="sd">    ENZYME      2.3.1.1</span>

<span class="sd">    PATHWAY     rn00220  Arginine biosynthesis</span>

<span class="sd">                rn01100  Metabolic pathways</span>

<span class="sd">                rn01110  Biosynthesis of secondary metabolites</span>

<span class="sd">                rn01210  2-Oxocarboxylic acid metabolism</span>

<span class="sd">                rn01230  Biosynthesis of amino acids</span>

<span class="sd">    MODULE      M00028  Ornithine biosynthesis, glutamate =&gt; ornithine</span>

<span class="sd">                M00845  Arginine biosynthesis, glutamate =&gt; acetylcitrulline =&gt; arginine</span>

<span class="sd">    ORTHOLOGY   K00618  amino-acid N-acetyltransferase [EC:2.3.1.1]</span>

<span class="sd">                K00619  amino-acid N-acetyltransferase [EC:2.3.1.1]</span>

<span class="sd">                K00620  glutamate N-acetyltransferase / amino-acid N-acetyltransferase [EC:2.3.1.35 2.3.1.1]</span>

<span class="sd">                K11067  N-acetylglutamate synthase [EC:2.3.1.1]</span>

<span class="sd">                K14681  argininosuccinate lyase / amino-acid N-acetyltransferase [EC:4.3.2.1 2.3.1.1]</span>

<span class="sd">                K14682  amino-acid N-acetyltransferase [EC:2.3.1.1]</span>

<span class="sd">                K22476  N-acetylglutamate synthase [EC:2.3.1.1]</span>

<span class="sd">                K22477  N-acetylglutamate synthase [EC:2.3.1.1]</span>

<span class="sd">                K22478  bifunctional N-acetylglutamate synthase/kinase [EC:2.3.1.1 2.7.2.8]</span>

<span class="sd">    DBLINKS     RHEA: 24295</span>

<span class="sd">    ///</span>

<span class="sd">    :param data: the KEGG reaction description.</span>
<span class="sd">    :return: the dictionary of parsed KEGG data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reaction_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">):</span>
            <span class="n">reaction_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;///&quot;</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">reaction_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">reaction_dict</span></div>


<div class="viewcode-block" id="parse_equation"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.parse_equation">[docs]</a><span class="k">def</span> <span class="nf">parse_equation</span><span class="p">(</span><span class="n">equation</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is to parse the KEGG reaction equation.</span>

<span class="sd">    eg:</span>
<span class="sd">    C00029 + C00001 + 2 C00003 &lt;=&gt; C00167 + 2 C00004 + 2 C00080</span>

<span class="sd">    :param equation: the equation string.</span>
<span class="sd">    :return: the parsed KEGG reaction equation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compound_pattern</span> <span class="o">=</span> <span class="s2">&quot;C.....&quot;</span>
    <span class="n">one_side_coefficients</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">the_other_side_coefficients</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current_side</span> <span class="o">=</span> <span class="n">one_side_coefficients</span>
    <span class="n">last_compound</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">equation</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">compound_pattern</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
            <span class="n">last_compound</span> <span class="o">=</span> <span class="n">token</span>
            <span class="n">current_side</span><span class="p">[</span><span class="n">last_compound</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
        <span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">current_side</span><span class="p">[</span><span class="n">last_compound</span><span class="p">]</span> <span class="o">=</span> <span class="n">token</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;&lt;=&gt;&quot;</span><span class="p">:</span>
            <span class="n">current_side</span> <span class="o">=</span> <span class="n">the_other_side_coefficients</span>
    <span class="k">return</span> <span class="n">one_side_coefficients</span><span class="p">,</span> <span class="n">the_other_side_coefficients</span></div>


<div class="viewcode-block" id="kegg_kcf_parser"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.kegg_kcf_parser">[docs]</a><span class="k">def</span> <span class="nf">kegg_kcf_parser</span><span class="p">(</span><span class="n">kcf</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is to parse KEGG kcf file to a dictionary.</span>

<span class="sd">    eg:</span>

<span class="sd">    ENTRY       C00013                      Compound</span>

<span class="sd">    ATOM        9</span>

<span class="sd">                1   P1b P    22.2269  -20.0662</span>

<span class="sd">                2   O2c O    23.5190  -20.0779</span>

<span class="sd">                3   O1c O    21.0165  -20.0779</span>

<span class="sd">                4   O1c O    22.2851  -21.4754</span>

<span class="sd">                5   O1c O    22.2617  -18.4642</span>

<span class="sd">                6   P1b P    24.8933  -20.0837</span>

<span class="sd">                7   O1c O    24.9401  -21.4811</span>

<span class="sd">                8   O1c O    26.1797  -20.0662</span>

<span class="sd">                9   O1c O    24.9107  -18.4582</span>

<span class="sd">    BOND        8</span>

<span class="sd">                1     1   2 1</span>

<span class="sd">                2     1   3 1</span>

<span class="sd">                3     1   4 1</span>

<span class="sd">                4     1   5 2</span>

<span class="sd">                5     2   6 1</span>

<span class="sd">                6     6   7 1</span>

<span class="sd">                7     6   8 1</span>

<span class="sd">                8     6   9 2</span>

<span class="sd">    ///</span>

<span class="sd">    :param kcf: the kcf text.</span>
<span class="sd">    :return: the dictionary of parsed kcf file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compound_name</span><span class="p">,</span> <span class="n">atom_count</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">bond_count</span><span class="p">,</span> <span class="n">bonds</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">kcf</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ENTRY&quot;</span><span class="p">:</span>
            <span class="n">compound_name</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ATOM&quot;</span><span class="p">:</span>
            <span class="n">atom_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;BOND&quot;</span><span class="p">:</span>
            <span class="n">bond_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;///&quot;</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atom_count</span><span class="p">:</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;atom_symbol&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;atom_number&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                              <span class="s2">&quot;kat&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bond_count</span><span class="p">:</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;first_atom_number&quot;</span><span class="p">:</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;second_atom_number&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;bond_type&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;compound_name&quot;</span><span class="p">:</span> <span class="n">compound_name</span><span class="p">,</span> <span class="s2">&quot;atoms&quot;</span><span class="p">:</span> <span class="n">atoms</span><span class="p">,</span> <span class="s2">&quot;bonds&quot;</span><span class="p">:</span> <span class="n">bonds</span><span class="p">}</span></div>


<span class="c1"># Define the reaction center in the rclass definition.</span>
<span class="n">reaction_center</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;reaction_center&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;kat&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;match&#39;</span><span class="p">,</span> <span class="s1">&#39;difference&#39;</span><span class="p">])</span>


<div class="viewcode-block" id="RpairParser"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser">[docs]</a><span class="k">class</span> <span class="nc">RpairParser</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is to get one-to-one atom mappings between two compounds based on the rclass definition.</span>

<span class="sd">        Several steps are involved in this process:</span>

<span class="sd">        1. The rclass definition can have several pieces. Each piece describes a center atom (R) and its connected atoms.</span>
<span class="sd">        The connected atoms can stay the same (M) or change (D) between the two compound structures.</span>

<span class="sd">        2. First we need to find the center atoms based on the rclass descriptions.</span>

<span class="sd">        3. For each center atom, there are can multiple candidates. In other words, based on the RDM description, a bunch</span>
<span class="sd">        of atoms in the compound can meet the descriptions. (One simple case are the symmetric compounds).</span>

<span class="sd">        4. Therefore, we need to generate the all the combinations for the center atoms in a compound.</span>

<span class="sd">            eg: if there are three atom centers, each center has several candidates:</span>

<span class="sd">                center 1: [0, 1, 2]; center 2: [5, 6]; center 3: [10, 11]</span>

<span class="sd">                The combinations for the center atoms:</span>

<span class="sd">                [0, 5, 10], [0, 5, 11], [0, 6, 10], [0, 6, 11], [1, 5, 10], [1, 5, 11], [1, 6, 10], [1, 6, 11], [2, 5, 10],</span>
<span class="sd">                [2, 5, 11], [2, 6, 10], [2, 6, 11]</span>

<span class="sd">        5. Next, we need to find the one-to-one atom mappings between the two compounds based on the mapped center atoms.</span>

<span class="sd">        6. To solve this issue, we first disassemble each compound into different components. This is due to the</span>
<span class="sd">        difference atoms in the two compounds, i.e. broken bonds.</span>

<span class="sd">        7. Then we need to find the mappings between each disassembled component, and concatenate the mappings of all</span>
<span class="sd">        the components.</span>

<span class="sd">        8. To find the one-to-one atom mappings, we use the BASS algorithm. We assume the mapped component have the same</span>
<span class="sd">        structure since we have already removed the different parts. However, here we only map the backbone of the</span>
<span class="sd">        structure (in other words, we simply all the bond type to 1) due to bond change (double bond to single bond or</span>
<span class="sd">        triple bond to single bond)</span>

<span class="sd">        9. To ensure the optimal mappings, we count the mapped atoms with changed local environment and choose the</span>
<span class="sd">        mapping with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RpairParser.__init__"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rclass_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">one_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">,</span>
                 <span class="n">other_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RpairParser initializer.</span>

<span class="sd">        :param rclass_name: the rclass name.</span>
<span class="sd">        :param rclass_definitions: a list of rclass definitions.</span>
<span class="sd">        :param one_compound: one compound involved in the pair.</span>
<span class="sd">        :param other_compound: the other compound involved in the pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rclass_name</span> <span class="o">=</span> <span class="n">rclass_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rclass_definitions</span> <span class="o">=</span> <span class="n">rclass_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span> <span class="o">=</span> <span class="n">one_compound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span> <span class="o">=</span> <span class="n">other_compound</span></div>
    
<div class="viewcode-block" id="RpairParser.map_atom_by_colors"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.map_atom_by_colors">[docs]</a>    <span class="k">def</span> <span class="nf">map_atom_by_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Roughly map the atoms between the two compounds by the atom color.</span>

<span class="sd">        :return: the dict of mapped atom index between the two compounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">color_compound</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">color_compound</span><span class="p">()</span>
        <span class="n">mapped</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom_2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom_1</span><span class="o">.</span><span class="n">color_layers</span> <span class="o">==</span> <span class="n">atom_2</span><span class="o">.</span><span class="n">color_layers</span><span class="p">:</span>
                    <span class="n">mapped</span><span class="p">[</span><span class="n">atom_1</span><span class="o">.</span><span class="n">atom_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_2</span><span class="o">.</span><span class="n">atom_number</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">mapped</span></div>

<div class="viewcode-block" id="RpairParser.map_whole_compound"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.map_whole_compound">[docs]</a>    <span class="k">def</span> <span class="nf">map_whole_compound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map two compounds if the two compounds can be roughly mapped by the atom color.</span>

<span class="sd">        :return: the dict of mapped atom in the two compounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">mapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_atom_by_colors</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapped</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        
        <span class="n">pre_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">find_mappings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="p">,</span> <span class="n">r_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">min_miscount</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">one_to_one_mappings</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pre_matches</span><span class="p">):</span>
            <span class="n">miscount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_changed_atom_identifiers</span><span class="p">(</span><span class="n">one_to_one_mappings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">miscount</span> <span class="o">&lt;</span> <span class="n">min_miscount</span><span class="p">:</span>
                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">min_miscount</span> <span class="o">=</span> <span class="n">miscount</span>
        <span class="k">return</span> <span class="n">pre_matches</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">min_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="p">{}</span></div>
    
<div class="viewcode-block" id="RpairParser.generate_kat_neighbors"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.generate_kat_neighbors">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_kat_neighbors</span><span class="p">(</span><span class="n">this_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the atom neighbors represented by KEGG atom type for each atom in the compound.</span>
<span class="sd">        This is used to find the center atom.</span>
<span class="sd">        We used KEGG atom type since the descriptions of atoms in the rclass definitions using KEGG atom type.</span>

<span class="sd">        :param this_compound: the compound entity.</span>
<span class="sd">        :return: the list of atom with its neighbors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">kat_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kat</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbors</span> <span class="k">if</span>
                             <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">default_symbol</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">]</span>
            <span class="n">kat_neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">kat</span><span class="p">,</span> <span class="n">kat_neighbors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atoms</span></div>

<div class="viewcode-block" id="RpairParser.find_target_atom"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.find_target_atom">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_target_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the target atoms from a list of candidate atoms.</span>

<span class="sd">        :param atoms: a list of atoms to search from.</span>
<span class="sd">        :param target: the target atom to be searched.</span>
<span class="sd">        :return: the list of atom numbers that match the target atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">target_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target_index</span></div>

<div class="viewcode-block" id="RpairParser.create_reaction_centers"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.create_reaction_centers">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_reaction_centers</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">kat</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">difference</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">the_other_difference</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                                <span class="n">the_other_match</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the center atom based on its connected atoms and its counterpart atom in the other compound.</span>

<span class="sd">        :param i: the ith rclass definition.</span>
<span class="sd">        :param kat: the KEGG atom type of the center atom.</span>
<span class="sd">        :param difference: the list of KEGG atom type of different connected atoms.</span>
<span class="sd">        :param the_other_difference: the list of KEGG atom type of different connected atoms in the other compound.</span>
<span class="sd">        :param match: the list of KEGG atom type of the matched connected atoms.</span>
<span class="sd">        :param the_other_match: the list of KEGG atom type of the matched connected atoms in the other compound.</span>
<span class="sd">        :return: the constructed reaction center.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">the_other_match</span><span class="p">))</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="n">the_other_difference</span><span class="p">))</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">match</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="n">kat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reaction_center</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">kat</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">difference</span><span class="p">)</span></div>

<div class="viewcode-block" id="RpairParser.find_center_atoms"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.find_center_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">find_center_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Example of rclass definition:</span>

<span class="sd">        C8x-C8y:\*-C1c:N5y+S2x-N5y+S2x</span>

<span class="sd">        The RDM pattern is defined as KEGG atom type changes at the reaction center (R), the difference region (D),</span>
<span class="sd">        and the matched region (M) for each reactant pair. It characterizes chemical structure transformation patterns</span>
<span class="sd">        associated with enzymatic reactions.</span>

<span class="sd">        :return: the list of reaction centers and the corresponding candidate atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_reaction_centers</span><span class="p">,</span> <span class="n">right_reaction_centers</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">left_center_candidates</span><span class="p">,</span> <span class="n">right_center_candidates</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">left_kat_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_kat_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="p">)</span>
        <span class="n">right_kat_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_kat_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">definition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rclass_definitions</span><span class="p">):</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">difference</span><span class="p">,</span> <span class="n">match</span> <span class="o">=</span> <span class="n">definition</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="n">left_center</span><span class="p">,</span> <span class="n">right_center</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">left_difference</span> <span class="o">=</span> <span class="p">[</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">difference</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">right_difference</span> <span class="o">=</span> <span class="p">[</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">difference</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">left_match</span> <span class="o">=</span> <span class="p">[</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">right_match</span> <span class="o">=</span> <span class="p">[</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">left_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">left_difference</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">left_match</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span>
            <span class="n">right_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">right_difference</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">right_match</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span>
            <span class="n">left_neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">right_neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">left_atom_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_target_atom</span><span class="p">(</span><span class="n">left_kat_neighbors</span><span class="p">,</span> <span class="p">(</span><span class="n">left_center</span><span class="p">,</span> <span class="n">left_neighbors</span><span class="p">))</span>
            <span class="n">right_atom_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_target_atom</span><span class="p">(</span><span class="n">right_kat_neighbors</span><span class="p">,</span> <span class="p">(</span><span class="n">right_center</span><span class="p">,</span> <span class="n">right_neighbors</span><span class="p">))</span>
            <span class="n">left_reaction_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_reaction_centers</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">left_center</span><span class="p">,</span> <span class="n">left_difference</span><span class="p">,</span> <span class="n">right_difference</span><span class="p">,</span>
                                                                      <span class="n">left_match</span><span class="p">,</span> <span class="n">right_match</span><span class="p">))</span>
            <span class="n">right_reaction_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_reaction_centers</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">right_center</span><span class="p">,</span> <span class="n">right_difference</span><span class="p">,</span>
                                                                       <span class="n">left_difference</span><span class="p">,</span> <span class="n">right_match</span><span class="p">,</span> <span class="n">left_match</span><span class="p">))</span>
            <span class="n">left_center_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_atom_index</span><span class="p">)</span>
            <span class="n">right_center_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_atom_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left_center_candidates</span><span class="p">,</span> <span class="n">right_center_candidates</span><span class="p">,</span> <span class="n">left_reaction_centers</span><span class="p">,</span> <span class="n">right_reaction_centers</span></div>

<div class="viewcode-block" id="RpairParser.get_center_list"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.get_center_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_center_list</span><span class="p">(</span><span class="n">center_atom_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate all the combinations of reaction centers.</span>
<span class="sd">        </span>
<span class="sd">        :param center_atom_index: list of atom index list for each reaction centers. eg: three reaction centers: [[0, 1, 2], [5, 6], [10, 11]].</span>
<span class="sd">        :return: the list of combined reaction centers. eg: [[0, 5, 10], [0, 5, 11], [0, 6, 10], [0, 6, 11], [1, 5, 10], [1, 5, 11], [1, 6, 10], [1, 6, 11], [2, 5, 10], [2, 5, 11], [2, 6, 10], [2, 6, 11]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">seen</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Use the depth first search algorithm to generate all the combinations of reaction centers.</span>

<span class="sd">            :param i: the current atom index.</span>
<span class="sd">            :param seen: the list of already seen atom index.</span>
<span class="sd">            :return: None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_atom_index</span><span class="p">):</span>
                <span class="n">combines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">seen</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">center_atom_index</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">combines</span></div>

<div class="viewcode-block" id="RpairParser.remove_different_bonds"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.remove_different_bonds">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">remove_different_bonds</span><span class="p">(</span><span class="n">this_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">,</span> <span class="n">center_atom_numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">reaction_centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the bonds connecting to different atoms. For each reaction center, multiple atoms can be the different</span>
<span class="sd">        atoms. We need to get all the combinations.</span>
<span class="sd">        </span>
<span class="sd">        :param this_compound: the :class:`~md_harmonize.compound.Compound` entity.</span>
<span class="sd">        :param center_atom_numbers: the list of atom numbers for center atom in the compound.</span>
<span class="sd">        :param reaction_centers: the list of reaction center descriptions for the compound.</span>
<span class="sd">        :return: the list of bonds (represented by the atom numbers in the bond) that needs to be removed based on the RDM descriptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">removed_bonds</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">center_atom_numbers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">different_atom</span> <span class="ow">in</span> <span class="n">reaction_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">difference</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">different_atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                    <span class="n">removed_bonds_update</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">possible_bonds</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">neighbor_index</span> <span class="ow">in</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">neighbor_index</span><span class="p">]</span><span class="o">.</span><span class="n">kat</span> <span class="o">==</span> <span class="n">different_atom</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">possible_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">neighbor_index</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">possible_bond</span> <span class="ow">in</span> <span class="n">possible_bonds</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">pre_removed</span> <span class="ow">in</span> <span class="n">removed_bonds</span><span class="p">:</span>
                                <span class="n">removed_bonds_update</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pre_removed</span> <span class="o">+</span> <span class="p">[</span><span class="n">possible_bond</span><span class="p">])</span>
                    <span class="n">removed_bonds</span> <span class="o">=</span> <span class="n">removed_bonds_update</span>
        <span class="k">return</span> <span class="n">removed_bonds</span></div>

<div class="viewcode-block" id="RpairParser.generate_atom_mappings"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.generate_atom_mappings">[docs]</a>    <span class="k">def</span> <span class="nf">generate_atom_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the one-to-one atom mappings of the compound pair.</span>

<span class="sd">        :return: the list of atom mappings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">optimal_atom_mappings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_whole_compound</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimal_atom_mappings</span><span class="p">:</span>
            <span class="n">left_center_candidates</span><span class="p">,</span> <span class="n">right_center_candidates</span><span class="p">,</span> <span class="n">left_reaction_centers</span><span class="p">,</span> <span class="n">right_reaction_centers</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">find_center_atoms</span><span class="p">()</span>
            <span class="n">left_centers_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_list</span><span class="p">(</span><span class="n">left_center_candidates</span><span class="p">)</span>
            <span class="n">right_center_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_list</span><span class="p">(</span><span class="n">right_center_candidates</span><span class="p">)</span>

            <span class="n">minimum_miss_count</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="n">optimal_atom_mappings</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">left_centers</span> <span class="ow">in</span> <span class="n">left_centers_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">right_centers</span> <span class="ow">in</span> <span class="n">right_center_list</span><span class="p">:</span>
                    <span class="c1"># After removing the bonds, the compound will be disassembled into several parts. Try to match</span>
                    <span class="c1"># these pieces.</span>
                    <span class="n">left_removed_bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_different_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="p">,</span> <span class="n">left_centers</span><span class="p">,</span>
                                                                         <span class="n">left_reaction_centers</span><span class="p">)</span>
                    <span class="n">right_removed_bonds_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_different_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">,</span>
                                                                           <span class="n">right_reaction_centers</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">left_removed_bonds</span> <span class="ow">in</span> <span class="n">left_removed_bond_list</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">right_removed_bonds</span> <span class="ow">in</span> <span class="n">right_removed_bonds_list</span><span class="p">:</span>
                            <span class="n">this_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_components</span><span class="p">(</span><span class="n">left_removed_bonds</span><span class="p">,</span> <span class="n">right_removed_bonds</span><span class="p">,</span> <span class="n">left_centers</span><span class="p">,</span>
                                                               <span class="n">right_centers</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">this_mapping</span><span class="p">:</span>
                                <span class="n">miss_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_changed_atom_identifiers</span><span class="p">(</span><span class="n">this_mapping</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimal_atom_mappings</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_mapping</span><span class="p">)</span> <span class="ow">or</span> \
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">optimal_atom_mappings</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_mapping</span><span class="p">)</span> <span class="ow">and</span> <span class="n">minimum_miss_count</span> <span class="o">&gt;</span> <span class="n">miss_count</span><span class="p">):</span>
                                    <span class="n">minimum_miss_count</span> <span class="o">=</span> <span class="n">miss_count</span>
                                    <span class="n">optimal_atom_mappings</span> <span class="o">=</span> <span class="n">this_mapping</span>

        <span class="n">one_to_one_mappings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">from_idx</span> <span class="ow">in</span> <span class="n">optimal_atom_mappings</span><span class="p">:</span>
            <span class="n">to_idx</span> <span class="o">=</span> <span class="n">optimal_atom_mappings</span><span class="p">[</span><span class="n">from_idx</span><span class="p">]</span>
            <span class="n">one_to_one_mappings</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">from_idx</span><span class="p">),</span>
                                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">to_idx</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">one_to_one_mappings</span></div>

<div class="viewcode-block" id="RpairParser.detect_components"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.detect_components">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">detect_components</span><span class="p">(</span><span class="n">this_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">,</span> <span class="n">removed_bonds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">center_atom_numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect all the components in the compound after removing some bonds.</span>
<span class="sd">        Basic idea is the breadth first search algorithm.</span>

<span class="sd">        :param this_compound: the :class:`~md_harmonize.compound.Compound` entity.</span>
<span class="sd">        :param removed_bonds: the list of removed bonds (represented by the atom numbers in the bond) in the compound.</span>
<span class="sd">        :param center_atom_numbers: the list of atom numbers of the center atoms in the compound.</span>
<span class="sd">        :return: the list of components of the compound represented by a list of atom numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">first_atom_number</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">second_atom_number</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_bonds</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">default_symbol</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span> <span class="ow">and</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">default_symbol</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="n">center_atom_numbers</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">ques</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
                <span class="n">component</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">ques</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">ques</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="n">component</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">neighbor_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">neighbor_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">)</span>
                            <span class="n">ques</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor_node</span><span class="p">)</span>
                <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span></div>

<div class="viewcode-block" id="RpairParser.pair_components"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.pair_components">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pair_components</span><span class="p">(</span><span class="n">left_components</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">right_components</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The two compounds are divided into separate components due to the difference atoms. We need to pair each component</span>
<span class="sd">        in one compound to its counterpart component in the other compound.</span>
<span class="sd">        Here we roughly pair the components based on the number of atoms in the component. Therefore, every component in</span>
<span class="sd">        one compound can be paired with several components in the other compound.</span>
<span class="sd">        </span>
<span class="sd">        :param left_components: the components in one compound.</span>
<span class="sd">        :param right_components: the components in the other compound.</span>
<span class="sd">        :return: the list of paired components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">component_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">left_component</span> <span class="ow">in</span> <span class="n">left_components</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">right_component</span> <span class="ow">in</span> <span class="n">right_components</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_component</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_component</span><span class="p">):</span>
                    <span class="n">component_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_component</span><span class="p">,</span> <span class="n">right_component</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">component_pairs</span></div>

<div class="viewcode-block" id="RpairParser.construct_component"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.construct_component">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">construct_component</span><span class="p">(</span><span class="n">this_compound</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">,</span> <span class="n">atom_numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">removed_bonds</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a :class:`~md_harmonize.compound.Compound` entity for the component based on the atom index and removed</span>
<span class="sd">        bonds, facilitating the following atom mappings.</span>

<span class="sd">        :param this_compound: the :class:`~md_harmonize.compound.Compound` entity.</span>
<span class="sd">        :param atom_numbers: the list of atom numbers in the component.</span>
<span class="sd">        :param removed_bonds: the list of removed bonds (represented by the atom numbers in the bond) in the compound.</span>
<span class="sd">        :return: the constructed component compound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">this_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">atom_numbers</span><span class="p">]</span>
        <span class="n">idx_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">atom_number</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">update_atom_number</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">this_compound</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">atom_1</span><span class="p">,</span> <span class="n">atom_2</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">first_atom_number</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">second_atom_number</span>
            <span class="k">if</span> <span class="n">atom_1</span> <span class="ow">in</span> <span class="n">atom_numbers</span> <span class="ow">and</span> <span class="n">atom_2</span> <span class="ow">in</span> <span class="n">atom_numbers</span> <span class="ow">and</span> <span class="p">(</span><span class="n">atom_1</span><span class="p">,</span> <span class="n">atom_2</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_bonds</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">atom_2</span><span class="p">,</span> <span class="n">atom_1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_bonds</span><span class="p">:</span>
                <span class="n">cloned_bond</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">cloned_bond</span><span class="o">.</span><span class="n">update_first_atom</span><span class="p">(</span><span class="n">idx_dict</span><span class="p">[</span><span class="n">atom_1</span><span class="p">])</span>
                <span class="n">cloned_bond</span><span class="o">.</span><span class="n">update_second_atom</span><span class="p">(</span><span class="n">idx_dict</span><span class="p">[</span><span class="n">atom_2</span><span class="p">])</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cloned_bond</span><span class="p">)</span>
        <span class="n">this_compound</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="s2">&quot;partial_compound&quot;</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this_compound</span></div>

<div class="viewcode-block" id="RpairParser.preliminary_atom_mappings_check"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.preliminary_atom_mappings_check">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">preliminary_atom_mappings_check</span><span class="p">(</span><span class="n">left_component</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">,</span> <span class="n">right_component</span><span class="p">:</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Roughly evaluate if the atoms between the two components can be mapped.</span>
<span class="sd">        We compare if the every atom color in the left component has its counterpart in the right component.</span>
<span class="sd">        Here, we only consider the backbone of the structure.</span>

<span class="sd">        :param left_component: the component in one compound.</span>
<span class="sd">        :param right_component: the component in the other compound.</span>
<span class="sd">        :return: bool whether the atoms in the two components can be mapped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_component</span><span class="o">.</span><span class="n">color_compound</span><span class="p">(</span><span class="n">r_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bond_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atom_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resonance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">backbone</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">right_component</span><span class="o">.</span><span class="n">color_compound</span><span class="p">(</span><span class="n">r_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bond_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atom_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resonance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">backbone</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_left</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_component</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atom_left</span><span class="o">.</span><span class="n">default_symbol</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">atom_right</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_component</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">atom_left</span><span class="o">.</span><span class="n">color_layers</span> <span class="o">==</span> <span class="n">atom_right</span><span class="o">.</span><span class="n">color_layers</span><span class="p">:</span>
                        <span class="n">mapped</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="n">mapped</span></div>

<div class="viewcode-block" id="RpairParser.map_components"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.map_components">[docs]</a>    <span class="k">def</span> <span class="nf">map_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_removed_bonds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">right_removed_bonds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">left_centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find optimal map for every component in the compound pair.</span>

<span class="sd">        :param left_removed_bonds: the list of removed bonds in one compound.</span>
<span class="sd">        :param right_removed_bonds: the list of removed bonds in the other compound.</span>
<span class="sd">        :param left_centers: the list of atom numbers of the center atoms in the one compound.</span>
<span class="sd">        :param right_centers: the list of atom numbers of the center atoms in the other compound.</span>
<span class="sd">        :return: the atom mappings for the compound pair based on the removed bonds and center atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_component_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="p">,</span> <span class="n">left_removed_bonds</span><span class="p">,</span> <span class="n">left_centers</span><span class="p">)</span>
        <span class="n">right_component_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="p">,</span> <span class="n">right_removed_bonds</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">)</span>
        <span class="n">component_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_components</span><span class="p">(</span><span class="n">left_component_list</span><span class="p">,</span> <span class="n">right_component_list</span><span class="p">)</span>
        <span class="n">atom_mappings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">left_component_index</span><span class="p">,</span> <span class="n">right_component_index</span> <span class="ow">in</span> <span class="n">component_pairs</span><span class="p">:</span>

            <span class="n">left_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_component</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="p">,</span> <span class="n">left_component_index</span><span class="p">,</span> <span class="n">left_removed_bonds</span><span class="p">)</span>
            <span class="n">right_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_component</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="p">,</span> <span class="n">right_component_index</span><span class="p">,</span> <span class="n">right_removed_bonds</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preliminary_atom_mappings_check</span><span class="p">(</span><span class="n">left_component</span><span class="p">,</span> <span class="n">right_component</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">one_to_one_mappings_list</span> <span class="o">=</span> <span class="n">left_component</span><span class="o">.</span><span class="n">find_mappings</span><span class="p">(</span><span class="n">right_component</span><span class="p">,</span> <span class="n">resonance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">r_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                    <span class="n">backbone</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">optimal_one_to_one_mappings</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">minimum_miss_count</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">one_to_one_mappings</span> <span class="ow">in</span> <span class="n">one_to_one_mappings_list</span><span class="p">:</span>
                <span class="n">original_index_mappings</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">one_to_one_mappings</span><span class="p">:</span>
                    <span class="n">original_index_mappings</span><span class="p">[</span><span class="n">left_component_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">right_component_index</span><span class="p">[</span><span class="n">one_to_one_mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_component_atom_mappings</span><span class="p">(</span><span class="n">left_centers</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">,</span> <span class="n">original_index_mappings</span><span class="p">):</span>
                    <span class="n">miss_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_changed_atom_identifiers</span><span class="p">(</span><span class="n">original_index_mappings</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">miss_count</span> <span class="o">&lt;</span> <span class="n">minimum_miss_count</span><span class="p">:</span>
                        <span class="n">minimum_miss_count</span> <span class="o">=</span> <span class="n">miss_count</span>
                        <span class="n">optimal_one_to_one_mappings</span> <span class="o">=</span> <span class="n">original_index_mappings</span>
            <span class="k">if</span> <span class="n">optimal_one_to_one_mappings</span><span class="p">:</span>
                <span class="n">atom_mappings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">optimal_one_to_one_mappings</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_atom_mappings</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">)</span></div>

<div class="viewcode-block" id="RpairParser.combine_atom_mappings"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.combine_atom_mappings">[docs]</a>    <span class="k">def</span> <span class="nf">combine_atom_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_mappings</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine the atom mappings of all the components.</span>
<span class="sd">        We just mentioned in the pair_components function that every component can have several mappings.</span>
<span class="sd">        Here, we choose the optimal mapping with the least count of changed atom local identifier. And make sure</span>
<span class="sd">        that each atom can only to mapped once.</span>

<span class="sd">        :param atom_mappings: the list of atom mappings for all the components.</span>
<span class="sd">        :return: the atom mappings for the compound pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">collective_mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_mapping</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">):</span>
            <span class="n">groups</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atom_mapping</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">collective_mappings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">[</span><span class="n">groups</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                <span class="n">orders</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_changed_atom_identifiers</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">atom_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collective_mappings</span> <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">atom_mappings</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="ow">and</span> \
                            <span class="nb">all</span><span class="p">(</span><span class="n">atom_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collective_mappings</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span>
                                <span class="n">atom_mappings</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                        <span class="n">collective_mappings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">collective_mappings</span></div>

<div class="viewcode-block" id="RpairParser.validate_component_atom_mappings"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.validate_component_atom_mappings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate_component_atom_mappings</span><span class="p">(</span><span class="n">left_centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">component_atom_mappings</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if mapped the atoms can correspond to the mapped reaction center atoms.</span>
<span class="sd">        </span>
<span class="sd">        :param left_centers: the list of center atom indices in the left compound.</span>
<span class="sd">        :param right_centers: the list of center atom indices in the right compound.</span>
<span class="sd">        :param component_atom_mappings: the one to one atom mappings of one component.</span>
<span class="sd">        :return: bool whether the mappings are valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left_centers</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component_atom_mappings</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">component_atom_mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="RpairParser.count_changed_atom_identifiers"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.RpairParser.count_changed_atom_identifiers">[docs]</a>    <span class="k">def</span> <span class="nf">count_changed_atom_identifiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one_to_one_mappings</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the mapped atoms with changed local atom identifier. The different atoms (D in RCLASS definitions)</span>
<span class="sd">        can cause change of local environment, which can change the atom identifier.</span>

<span class="sd">        :param one_to_one_mappings: the dictionary of atom mappings between the two compounds.</span>
<span class="sd">        :return: the total number of mapped atoms with different local identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx_1</span> <span class="ow">in</span> <span class="n">one_to_one_mappings</span><span class="p">:</span>
            <span class="n">idx_2</span> <span class="o">=</span> <span class="n">one_to_one_mappings</span><span class="p">[</span><span class="n">idx_1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx_1</span><span class="p">]</span><span class="o">.</span><span class="n">color_layers</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx_2</span><span class="p">]</span><span class="o">.</span><span class="n">color_layers</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">one_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx_1</span><span class="p">]</span><span class="o">.</span><span class="n">color_layers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_compound</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx_2</span><span class="p">]</span><span class="o">.</span><span class="n">color_layers</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div></div>


<div class="viewcode-block" id="create_compound_kcf"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.create_compound_kcf">[docs]</a><span class="k">def</span> <span class="nf">create_compound_kcf</span><span class="p">(</span><span class="n">kcf_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct compound entity based on the KEGG kcf file.</span>

<span class="sd">    :param kcf_file: the path to the kcf file.</span>
<span class="sd">    :return: the constructed compound entity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kcf_dict</span> <span class="o">=</span> <span class="n">kegg_kcf_parser</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">open_text</span><span class="p">(</span><span class="n">kcf_file</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">compound</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="s2">&quot;atom_symbol&quot;</span><span class="p">],</span> <span class="n">atom</span><span class="p">[</span><span class="s2">&quot;atom_number&quot;</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">atom</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">atom</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">kat</span><span class="o">=</span><span class="n">atom</span><span class="p">[</span><span class="s2">&quot;kat&quot;</span><span class="p">])</span> <span class="k">for</span>
             <span class="n">atom</span> <span class="ow">in</span> <span class="n">kcf_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]]</span>
    <span class="n">bonds</span> <span class="o">=</span> <span class="p">[</span><span class="n">compound</span><span class="o">.</span><span class="n">Bond</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="s2">&quot;first_atom_number&quot;</span><span class="p">],</span> <span class="n">bond</span><span class="p">[</span><span class="s2">&quot;second_atom_number&quot;</span><span class="p">],</span> <span class="n">bond</span><span class="p">[</span><span class="s2">&quot;bond_type&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span>
             <span class="n">kcf_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">this_compound</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="n">kcf_dict</span><span class="p">[</span><span class="s2">&quot;compound_name&quot;</span><span class="p">],</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">this_compound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">this_compound</span></div>


<span class="c1"># when we create the kegg reaction, we need to parse the atom mappings based on rclass!</span>
<span class="c1"># To avoid parsing the same rclass repeatedly, let&#39;s parse the rclass first, and look it up when we need.</span>
<div class="viewcode-block" id="create_reactions"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.create_reactions">[docs]</a><span class="k">def</span> <span class="nf">create_reactions</span><span class="p">(</span><span class="n">reaction_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">atom_mappings</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create KEGG :class:`~md_harmonize.reaction.Reaction` entities.</span>

<span class="sd">    :param reaction_directory: the directory that stores all the reaction files.</span>
<span class="sd">    :param atom_mappings: the compound pair name and its atom mappings.</span>
<span class="sd">    :return: the constructed :class:`~md_harmonize.reaction.Reaction` entities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># here we create compounds, rlcass descriptions, and reactions.</span>
    <span class="n">reaction_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">reaction_directory</span><span class="o">+</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>
    <span class="n">reactions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">reaction_file</span> <span class="ow">in</span> <span class="n">reaction_files</span><span class="p">:</span>
        <span class="n">this_reaction</span> <span class="o">=</span> <span class="n">kegg_data_parser</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">open_text</span><span class="p">(</span><span class="n">reaction_file</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="n">reaction_name</span> <span class="o">=</span> <span class="n">this_reaction</span><span class="p">[</span><span class="s2">&quot;ENTRY&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">one_side_coefficients</span><span class="p">,</span> <span class="n">the_other_side_coefficients</span> <span class="o">=</span> <span class="n">parse_equation</span><span class="p">(</span><span class="n">this_reaction</span><span class="p">[</span><span class="s2">&quot;EQUATION&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">one_side_compounds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cpd:&quot;</span> <span class="o">+</span> <span class="n">compound_name</span> <span class="k">for</span> <span class="n">compound_name</span> <span class="ow">in</span> <span class="n">one_side_coefficients</span><span class="p">]</span>
        <span class="n">the_other_side_compounds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cpd:&quot;</span> <span class="o">+</span> <span class="n">compound_name</span> <span class="k">for</span> <span class="n">compound_name</span> <span class="ow">in</span> <span class="n">the_other_side_coefficients</span><span class="p">]</span>
        <span class="n">one_side_coefficients</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">the_other_side_coefficients</span><span class="p">)</span>

        <span class="n">raw_ecs</span> <span class="o">=</span> <span class="n">this_reaction</span><span class="p">[</span><span class="s2">&quot;ENZYME&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;ENZYME&quot;</span> <span class="ow">in</span> <span class="n">this_reaction</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">ecs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">raw_ecs</span><span class="p">:</span>
            <span class="n">ec_numbers</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">ec_numbers</span><span class="p">:</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="c1"># some numbers in the ec are not specified. like &quot;3.5.99.-&quot;</span>
                <span class="k">while</span> <span class="n">numbers</span> <span class="ow">and</span> <span class="n">numbers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="n">numbers</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">ecs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ecs</span><span class="p">:</span>
            <span class="c1"># ORTHOLOGY can contain information of ecs. Please check the example of reaction.</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">this_reaction</span><span class="p">[</span><span class="s2">&quot;ORTHOLOGY&quot;</span><span class="p">]:</span>
                <span class="n">ec_pattern</span> <span class="o">=</span> <span class="s2">&quot;\[EC:.*\]&quot;</span>
                <span class="n">ec_numbers</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">ec_pattern</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ec_numbers</span><span class="p">:</span>
                    <span class="n">ec_numbers</span> <span class="o">=</span> <span class="n">ec_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">ec_numbers</span><span class="p">:</span>
                        <span class="n">numbers</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">numbers</span> <span class="ow">and</span> <span class="n">numbers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                            <span class="n">numbers</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">ecs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>

        <span class="n">this_atom_mappings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">this_reaction</span><span class="p">[</span><span class="s2">&quot;RCLASS&quot;</span><span class="p">]:</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">rclass</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">compound_pairs</span> <span class="o">=</span> <span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">compound_pair</span> <span class="ow">in</span> <span class="n">compound_pairs</span><span class="p">:</span>
                <span class="n">cpd_1</span><span class="p">,</span> <span class="n">cpd_2</span> <span class="o">=</span> <span class="n">compound_pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">key_1</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">rclass</span><span class="p">,</span> <span class="n">cpd_1</span><span class="p">,</span> <span class="n">cpd_2</span><span class="p">])</span>
                <span class="n">key_2</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">rclass</span><span class="p">,</span> <span class="n">cpd_2</span><span class="p">,</span> <span class="n">cpd_1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">key_1</span> <span class="ow">in</span> <span class="n">atom_mappings</span><span class="p">:</span>
                    <span class="n">this_atom_mappings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">[</span><span class="n">key_1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">key_2</span> <span class="ow">in</span> <span class="n">atom_mappings</span><span class="p">:</span>
                    <span class="n">this_atom_mappings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">atom_mappings</span><span class="p">[</span><span class="n">key_2</span><span class="p">])</span>
        <span class="n">reactions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reaction</span><span class="o">.</span><span class="n">Reaction</span><span class="p">(</span><span class="n">reaction_name</span><span class="p">,</span> <span class="n">one_side_compounds</span><span class="p">,</span> <span class="n">the_other_side_compounds</span><span class="p">,</span> <span class="n">ecs</span><span class="p">,</span>
                                           <span class="n">this_atom_mappings</span><span class="p">,</span> <span class="n">one_side_coefficients</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">reactions</span></div>


<span class="c1"># def compound_pair_mappings(rclass_name: str, rclass_definitions: list, one_compound: compound.Compound,</span>
<span class="c1">#                            the_other_compound: compound.Compound) -&gt; tuple:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     To get the atom mappings between two compounds based on the rclass definitions.</span>
<span class="c1">#</span>
<span class="c1">#     :param rclass_name: the name of the rclass.</span>
<span class="c1">#     :param rclass_definitions: the list of rclass definitions.</span>
<span class="c1">#     :param one_compound: one compound entity involved in the compound pair.</span>
<span class="c1">#     :param the_other_compound: the other compound entity involved in the compound pair.</span>
<span class="c1">#     :return: the compound pair name and its atom mappings.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     atom_mappings = []</span>
<span class="c1">#     # print(&quot;parse this pair&quot;, one_compound.compound_name, the_other_compound.compound_name)</span>
<span class="c1">#     try:</span>
<span class="c1">#         one_mappings = RpairParser(rclass_name, rclass_definitions, one_compound, the_other_compound).\</span>
<span class="c1">#             generate_atom_mappings()</span>
<span class="c1">#         the_other_mappings = RpairParser(rclass_name, rclass_definitions, the_other_compound, one_compound).\</span>
<span class="c1">#             generate_atom_mappings()</span>
<span class="c1">#         atom_mappings = one_mappings if len(one_mappings) &gt; len(the_other_mappings) else the_other_mappings</span>
<span class="c1">#     except Exception as e:</span>
<span class="c1">#         print(rclass_name + &quot;_&quot; + one_compound.name + &quot;_&quot; + the_other_compound.name +</span>
<span class="c1">#               &quot;can hardly be parsed.&quot;)</span>
<span class="c1">#         pass</span>
<span class="c1">#     return one_compound.name + &quot;_&quot; + the_other_compound.name, atom_mappings</span>


<span class="c1"># def multiple_compound_pair_mappings(rclass_name: str, rclass_definitions: list, one_compound: compound.Compound,</span>
<span class="c1">#                                     the_other_compound: compound.Compound) -&gt; tuple:</span>
<span class="c1">#     try:</span>
<span class="c1">#         with tools.timeout(seconds=10):</span>
<span class="c1">#             return compound_pair_mappings(rclass_name, rclass_definitions, one_compound, the_other_compound)</span>
<span class="c1">#     except Exception as exception:</span>
<span class="c1">#         print(&quot;fail to pass this due to timeout: &quot;, rclass_name, one_compound.compound_name, the_other_compound.compound_name)</span>
<span class="c1">#         return one_compound.name + &quot;_&quot; + the_other_compound.name, []</span>


<span class="c1"># def multiple_compound_pair_mappings(rclass_name: str, rclass_definitions: list, one_compound: compound.Compound,</span>
<span class="c1">#                                     the_other_compound: compound.Compound) -&gt; tuple:</span>
<span class="c1">#     start_time = datetime.now()</span>
<span class="c1">#     try:</span>
<span class="c1">#         name, mappings = tools.timeout(compound_pair_mappings, (rclass_name, rclass_definitions, one_compound,</span>
<span class="c1">#                                                                 the_other_compound,), seconds=1200)</span>
<span class="c1">#         end_time = datetime.now()</span>
<span class="c1">#         consumed = end_time - start_time</span>
<span class="c1">#         print(&quot;parsing of this {0} {1} {2} cost {3}&quot;.format(rclass_name, one_compound.compound_name, the_other_compound.compound_name, consumed.total_seconds()))</span>
<span class="c1">#         return name, mappings</span>
<span class="c1">#     except Exception as exception:</span>
<span class="c1">#         print(&quot;fail to pass this due to timeout: &quot;, rclass_name, one_compound.compound_name, the_other_compound.compound_name)</span>
<span class="c1">#         end_time = datetime.now()</span>
<span class="c1">#         consumed = end_time - start_time</span>
<span class="c1">#         print(&quot;parsing of this {0} {1} {2} cost {3}&quot;.format(rclass_name, one_compound.compound_name, the_other_compound.compound_name, consumed.total_seconds()))</span>
<span class="c1">#         return one_compound.name + &quot;_&quot; + the_other_compound.name, []</span>

<div class="viewcode-block" id="compound_pair_mappings"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.compound_pair_mappings">[docs]</a><span class="k">def</span> <span class="nf">compound_pair_mappings</span><span class="p">(</span><span class="n">pair_component</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the atom mappings between two compounds based on the rclass definitions.</span>

<span class="sd">    :param pair_component: a tuple containing the rclass_name, rclass_definitions, one_compound and the_other_compound.</span>
<span class="sd">    :return: the compound pair name and its atom mappings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rclass_name</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">,</span> <span class="n">one_compound</span><span class="p">,</span> <span class="n">other_compound</span> <span class="o">=</span> <span class="n">pair_component</span>
    <span class="n">atom_mappings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># print(&quot;parse this pair&quot;, one_compound.compound_name, the_other_compound.compound_name)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">one_mappings</span> <span class="o">=</span> <span class="n">RpairParser</span><span class="p">(</span><span class="n">rclass_name</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">,</span> <span class="n">one_compound</span><span class="p">,</span> <span class="n">other_compound</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">generate_atom_mappings</span><span class="p">()</span>
        <span class="n">other_mappings</span> <span class="o">=</span> <span class="n">RpairParser</span><span class="p">(</span><span class="n">rclass_name</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">,</span> <span class="n">other_compound</span><span class="p">,</span> <span class="n">one_compound</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">generate_atom_mappings</span><span class="p">()</span>
        <span class="n">atom_mappings</span> <span class="o">=</span> <span class="n">one_mappings</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">one_mappings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_mappings</span><span class="p">)</span> <span class="k">else</span> <span class="n">other_mappings</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">rclass_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">one_compound</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">other_compound</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
              <span class="s2">&quot;can hardly be parsed.&quot;</span><span class="p">)</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">one_compound</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">other_compound</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom_mappings</span></div>


<div class="viewcode-block" id="create_atom_mappings"><a class="viewcode-back" href="../../api.html#md_harmonize.KEGG_parser.create_atom_mappings">[docs]</a><span class="k">def</span> <span class="nf">create_atom_mappings</span><span class="p">(</span><span class="n">rclass_directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compounds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">seconds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1200</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the atom mappings between compounds based on RCLASS definitions.</span>

<span class="sd">    :param rclass_directory: the directory that stores the rclass files.</span>
<span class="sd">    :param compounds: a dictionary of :class:`~md_harmonize.compound.Compound` entities.</span>
<span class="sd">    :param seconds: the timeout limit.</span>
<span class="sd">    :return: the atom mappings of compound pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rclass_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">rclass_directory</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span>
    <span class="n">atom_mappings</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rclass_file</span> <span class="ow">in</span> <span class="n">rclass_files</span><span class="p">:</span>
        <span class="n">this_rclass</span> <span class="o">=</span> <span class="n">kegg_data_parser</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">open_text</span><span class="p">(</span><span class="n">rclass_file</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="n">rclass_definitions</span> <span class="o">=</span> <span class="n">this_rclass</span><span class="p">[</span><span class="s2">&quot;DEFINITION&quot;</span><span class="p">]</span>
        <span class="n">rclass_name</span> <span class="o">=</span> <span class="n">this_rclass</span><span class="p">[</span><span class="s2">&quot;ENTRY&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;currently work on rclass: &quot;</span><span class="p">,</span> <span class="n">rclass_name</span><span class="p">)</span>
        <span class="n">compound_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">this_rclass</span><span class="p">[</span><span class="s2">&quot;RPAIR&quot;</span><span class="p">]:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="n">one_compound_name</span><span class="p">,</span> <span class="n">other_compound_name</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">one_compound_name</span> <span class="ow">in</span> <span class="n">compounds</span> <span class="ow">and</span> <span class="n">other_compound_name</span> <span class="ow">in</span> <span class="n">compounds</span><span class="p">:</span>
                    <span class="n">compound_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">compounds</span><span class="p">[</span><span class="n">one_compound_name</span><span class="p">],</span> <span class="n">compounds</span><span class="p">[</span><span class="n">other_compound_name</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compound_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">pebble</span><span class="o">.</span><span class="n">ProcessPool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pre_results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">compound_pair_mappings</span><span class="p">,</span> <span class="p">[(</span><span class="n">rclass_name</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">,</span> <span class="n">one_compound</span><span class="p">,</span>
                                                                 <span class="n">other_compound</span><span class="p">,)</span> <span class="k">for</span> <span class="n">one_compound</span><span class="p">,</span> <span class="n">other_compound</span> <span class="ow">in</span> <span class="n">compound_pairs</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="n">seconds</span><span class="p">)</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="n">pre_results</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">this_result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_result</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="n">CF</span><span class="o">.</span><span class="n">TimeoutError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;function took longer than </span><span class="si">%d</span><span class="s2"> seconds&quot;</span><span class="o">%</span><span class="n">error</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">except</span> <span class="n">pebble</span><span class="o">.</span><span class="n">ProcessExpired</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">. Exit code: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">exitcode</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;function raised </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">error</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">traceback</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">compound_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">compound_pair_mappings</span><span class="p">((</span><span class="n">rclass_name</span><span class="p">,</span> <span class="n">rclass_definitions</span><span class="p">,</span> <span class="n">compound_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">compound_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],))]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">atom_mappings</span><span class="p">[</span><span class="n">rclass_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;empty mappings&quot;</span><span class="p">,</span> <span class="n">rclass_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atom_mappings</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">md_harmonize</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">The md_harmonize Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">The md_harmonize API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Huan Jin & Hunter Moseley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>